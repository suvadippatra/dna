<meta name='viewport' content='width=device-width, initial-scale=1'/><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scroll-Driven DNA Assembly</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <canvas id="dnaCanvas"></canvas>

    <div class="scroll-container">
        <div class="scroll-height"></div>
    </div>

    <div id="ui-layer">
        <div class="instruction">Scroll Up to Construct DNA &uarr;</div>
    </div>

    <script src="main.js"></script>
</body>
</html>
<style>:root {
    --paper-color: #fcfbf9;
    --ink-color: #2c3e50;
    --font-main: 'Patrick Hand', cursive;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background-color: var(--paper-color);
    color: var(--ink-color);
    font-family: var(--font-main);
    overflow-x: hidden;
    /* Hide scrollbar for immersion */
    scrollbar-width: none;  /* Firefox */
    -ms-overflow-style: none;  /* IE/Edge */
}

body::-webkit-scrollbar {
    display: none; /* Chrome/Safari */
}

canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 1;
}

/* Invisible container to enable scrolling */
.scroll-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    z-index: 2;
    pointer-events: none; /* Touches pass through to canvas/body */
}

/* Height determines animation duration */
.scroll-height {
    height: 1200vh; /* 12x screen height for long, smooth assembly */
}

#ui-layer {
    position: fixed;
    bottom: 30px;
    width: 100%;
    text-align: center;
    z-index: 3;
    pointer-events: none;
}

.instruction {
    display: inline-block;
    background: rgba(255, 255, 255, 0.9);
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 1.5rem;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    animation: float 2s infinite ease-in-out;
}

@keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}
</style><script>const canvas = document.getElementById('dnaCanvas');
const ctx = canvas.getContext('2d');

// --- Configuration ---
let width, height;
let scrollProgress = 0;
let globalTime = 0;

// DNA Parameters
const BASE_PAIRS = 24;      // Number of steps visible
const RADIUS = 140;         // Helix radius
const RISE = 30;            // Distance between steps
const TWIST = 0.6;          // Radians per step (approx 34-36 deg)

// Colors (CPK-ish standard)
const C_COLOR = '#505050';  // Carbon
const N_COLOR = '#3498db';  // Nitrogen
const O_COLOR = '#e74c3c';  // Oxygen
const P_COLOR = '#f39c12';  // Phosphorus
const H_COLOR = '#ecf0f1';  // Hydrogen
const BOND_COLOR = '#555';
const HBOND_COLOR = '#9b59b6'; // Distinct color for H-bonds

// --- Molecular Geometry Data (Relative Coordinates) ---
// Defined roughly in Angstrom-scale ratios relative to attachment point (0,0)

// Helper to define atoms: [x, y, element, label]
// Coordinates approximate the planar structure of bases.

const ADENINE = {
    atoms: [
        {x:0, y:0, el:'N'}, // N9 (Connects to sugar)
        {x:20, y:12, el:'C'}, {x:40, y:0, el:'N'}, {x:30, y:-18, el:'C'}, {x:10, y:-18, el:'C'},
        {x:10, y:12, el:'C'}, // Ring fusion
        {x:10, y:35, el:'N'}, {x:-15, y:45, el:'C'}, {x:-35, y:35, el:'N'}, {x:-35, y:12, el:'C'},
        {x:-55, y:55, el:'N', h:2}, // Exocyclic Amine (N6) - H-bond donor
        {x:-35, y:12, el:'C'}
    ],
    bonds: [[0,1],[1,2],[2,3],[3,4],[4,0],[0,5],[5,6],[6,7],[7,8],[8,9],[9,5],[7,10]],
    hBondSource: [10, 8] // Indices for H-bonds (N6, N1)
};

const THYMINE = {
    atoms: [
        {x:0, y:0, el:'N'}, // N1 (Connects to sugar)
        {x:20, y:12, el:'C'}, {x:35, y:0, el:'O'}, // O2
        {x:20, y:35, el:'N', h:1}, // N3 - H-bond donor
        {x:0, y:45, el:'C'}, {x:-15, y:55, el:'O'}, // O4 - H-bond acceptor
        {x:-20, y:35, el:'C'}, {x:-40, y:45, el:'C', h:3}, // Methyl
        {x:-20, y:12, el:'C'}
    ],
    bonds: [[0,1],[1,2],[1,2],[1,2],[1,3],[3,4],[4,5],[4,6],[6,7],[6,8],[8,0]],
    hBondSource: [3, 4] // N3, O4
};

const GUANINE = {
    atoms: [
        {x:0, y:0, el:'N'}, // N9
        {x:20, y:12, el:'C'}, {x:40, y:0, el:'N'}, {x:30, y:-18, el:'C'}, {x:10, y:-18, el:'C'},
        {x:10, y:12, el:'C'},
        {x:10, y:35, el:'N'}, {x:-15, y:45, el:'C'}, {x:-30, y:60, el:'O'}, // O6
        {x:-35, y:35, el:'N', h:1}, // N1
        {x:-35, y:12, el:'C'}, {x:-55, y:0, el:'N', h:2} // N2
    ],
    bonds: [[0,1],[1,2],[2,3],[3,4],[4,0],[0,5],[5,6],[6,7],[7,8],[7,9],[9,10],[10,5],[10,11]],
    hBondSource: [8, 9, 11] // O6, N1, N2
};

const CYTOSINE = {
    atoms: [
        {x:0, y:0, el:'N'}, // N1
        {x:20, y:12, el:'C'}, {x:35, y:0, el:'O'}, // O2
        {x:20, y:35, el:'N'}, // N3
        {x:0, y:45, el:'C'}, {x:-15, y:55, el:'N', h:2}, // N4
        {x:-20, y:35, el:'C'},
        {x:-20, y:12, el:'C'}
    ],
    bonds: [[0,1],[1,2],[1,3],[3,4],[4,5],[4,6],[6,0]],
    hBondSource: [2, 4, 1] // N3, N4, O2
};

// Backbone Template (Sugar-Phosphate)
// Simplified 3D coords for Deoxyribose + Phosphate group
const BACKBONE = {
    atoms: [
        {x:0, y:0, el:'C'}, // C1' (Base attach)
        {x:15, y:10, el:'C'}, // C2'
        {x:10, y:25, el:'C'}, // C3' (Downstream P attach)
        {x:-10, y:20, el:'C'}, // C4'
        {x:-20, y:30, el:'C'}, // C5'
        {x:-5, y:5, el:'O'}, // Ring O
        {x:-35, y:40, el:'P'}, // Phosphate
        {x:-35, y:55, el:'O'}, {x:-50, y:30, el:'O'}, {x:-20, y:40, el:'O'} // Phosphate oxygens
    ],
    bonds: [[0,1],[1,2],[2,3],[3,4],[4,6],[6,7],[6,8],[6,9],[3,5],[5,0]]
};

// --- Sequence Generation ---
const sequence = [];
for (let i = 0; i < BASE_PAIRS + 10; i++) { // Extra for scrolling buffer
    const r = Math.random();
    if (r < 0.25) sequence.push(['A', 'T']);
    else if (r < 0.5) sequence.push(['T', 'A']);
    else if (r < 0.75) sequence.push(['G', 'C']);
    else sequence.push(['C', 'G']);
}

// --- View/Resize Handler ---
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- 3D Helper Functions ---
function rotateY(point, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return {
        x: point.x * cos - point.z * sin,
        y: point.y,
        z: point.x * sin + point.z * cos
    };
}

function project(point) {
    const fov = 800;
    const scale = fov / (fov + point.z + 400);
    return {
        x: width / 2 + point.x * scale,
        y: height / 2 + point.y * scale,
        scale: scale,
        z: point.z // Pass Z for sorting
    };
}

// --- Drawing Helpers ---
function drawAtom(p, type, alpha) {
    const r = (type === 'H' ? 3 : (type === 'P' ? 7 : 5)) * p.scale;
    let color = type === 'C' ? C_COLOR : type === 'N' ? N_COLOR : type === 'O' ? O_COLOR : type === 'P' ? P_COLOR : H_COLOR;
    
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.globalAlpha = 1;
}

function drawLine(p1, p2, color, width, dashed, alpha) {
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = color;
    ctx.lineWidth = width * ((p1.scale + p2.scale) / 2);
    if (dashed) ctx.setLineDash([5, 5]);
    else ctx.setLineDash([]);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.globalAlpha = 1;
}

// --- Main Render Loop ---
function animate() {
    ctx.clearRect(0, 0, width, height);

    // 1. Calculate Scroll & Time
    const totalScroll = document.body.scrollHeight - window.innerHeight;
    scrollProgress = Math.min(1, Math.max(0, window.scrollY / totalScroll));
    
    // Continuous rotation
    globalTime += 0.005;
    
    // 2. Determine Phase
    // Phase 1: Formation (0.0 - 0.7)
    // Phase 2: Simplification (0.7 - 1.0)
    const formProgress = Math.min(1, scrollProgress * 1.4); 
    const simplicityProgress = Math.max(0, (scrollProgress - 0.7) / 0.3);

    // The "Formation Line" moves up as we scroll
    const activeIndex = Math.floor(formProgress * BASE_PAIRS);
    
    // Render Queue for Z-Sorting
    const queue = [];

    // 3. Build the Structure
    for (let i = 0; i < BASE_PAIRS; i++) {
        const pair = sequence[i];
        const leftType = pair[0];
        const rightType = pair[1];
        
        // Visibility Check
        // Items fade in as the scroll passes them
        const itemProgress = Math.max(0, Math.min(1, (formProgress * BASE_PAIRS - i + 2) / 3));
        if (itemProgress <= 0) continue; // Not formed yet

        // Coordinates Calculation
        const yBase = (i - BASE_PAIRS / 2) * RISE + (scrollProgress * 200); // Move up slightly on scroll
        const twistAngle = i * TWIST + globalTime;
        
        // "Soup" logic: Random offset if not fully formed
        const chaos = (1 - itemProgress) * 300; 
        const soupX = Math.sin(i * 1324) * chaos;
        const soupY = Math.cos(i * 234) * chaos;
        const soupZ = Math.sin(i * 55) * chaos;

        // --- Left Strand (5' -> 3') ---
        const leftMol = (leftType === 'A') ? ADENINE : (leftType === 'T') ? THYMINE : (leftType === 'G') ? GUANINE : CYTOSINE;
        const lOffset = -60; // Offset from helix axis
        
        // Transform function for Left Base
        const transformLeft = (atomX, atomY) => {
            // 1. Orient molecule: A/G connect at N9, T/C at N1. 
            // We rotate them 90deg to face center.
            let rx = atomX; 
            let ry = atomY; 
            
            // 2. Position in Helix (before twist)
            let hx = rx + lOffset;
            let hy = ry + yBase + soupY;
            let hz = 0;

            // 3. Twist
            let twisted = rotateY({x: hx, y: hy, z: hz}, twistAngle);
            
            // 4. Add Soup chaos
            return {
                x: twisted.x + soupX,
                y: twisted.y,
                z: twisted.z + soupZ
            };
        };

        // --- Right Strand (3' -> 5') ---
        const rightMol = (rightType === 'A') ? ADENINE : (rightType === 'T') ? THYMINE : (rightType === 'G') ? GUANINE : CYTOSINE;
        const rOffset = 60;
        
        // Transform function for Right Base (Antiparallel flip)
        const transformRight = (atomX, atomY) => {
            // Mirror and flip for antiparallel
            let rx = -atomX; 
            let ry = -atomY; 
            
            let hx = rx + rOffset;
            let hy = ry + yBase + soupY;
            let hz = 0;

            let twisted = rotateY({x: hx, y: hy, z: hz}, twistAngle);
            
            return {
                x: twisted.x - soupX, // Opposite chaos
                y: twisted.y,
                z: twisted.z - soupZ
            };
        };

        // --- Collect Data for Rendering ---
        // We only render atoms if simplicityProgress < 1. 
        // If high simplicity, we draw lines.

        const alphaMolecular = (1 - simplicityProgress) * itemProgress;
        const alphaSchematic = simplicityProgress * itemProgress;

        // --- MOLECULAR VIEW ---
        if (alphaMolecular > 0.1) {
            // Process Left Base
            const lPts = leftMol.atoms.map(a => transformLeft(a.x, a.y));
            const lProj = lPts.map(project);
            
            // Atoms
            lProj.forEach((p, idx) => {
                queue.push({z: p.z, draw: () => drawAtom(p, leftMol.atoms[idx].el, alphaMolecular)});
            });
            // Bonds
            leftMol.bonds.forEach(b => {
                queue.push({z: lProj[b[0]].z, draw: () => drawLine(lProj[b[0]], lProj[b[1]], BOND_COLOR, 2, false, alphaMolecular)});
            });

            // Process Right Base
            const rPts = rightMol.atoms.map(a => transformRight(a.x, a.y));
            const rProj = rPts.map(project);
            
            rProj.forEach((p, idx) => {
                queue.push({z: p.z, draw: () => drawAtom(p, rightMol.atoms[idx].el, alphaMolecular)});
            });
            rightMol.bonds.forEach(b => {
                queue.push({z: rProj[b[0]].z, draw: () => drawLine(rProj[b[0]], rProj[b[1]], BOND_COLOR, 2, false, alphaMolecular)});
            });

            // H-Bonds (Connect specific atoms)
            // A-T (2 bonds), G-C (3 bonds)
            // We use the 'hBondSource' indices defined in templates.
            // Simplified: Connect ith donor to ith acceptor
            if (itemProgress > 0.9) { // Only form H-bonds when close
                const count = Math.min(leftMol.hBondSource.length, rightMol.hBondSource.length);
                for(let k=0; k<count; k++) {
                    const idx1 = leftMol.hBondSource[k];
                    const idx2 = rightMol.hBondSource[k]; // Assume ordered match for simplicity
                    queue.push({z: lProj[idx1].z, draw: () => drawLine(lProj[idx1], rProj[idx2], HBOND_COLOR, 2, true, alphaMolecular)});
                }
            }

            // Backbone (Simplified Spheres for Backbones to save perf)
            // Left Backbone
            const bbL = rotateY({x: -RADIUS, y: yBase, z: 0}, twistAngle);
            const bbLProj = project(bbL);
            queue.push({z: bbL.z, draw: () => drawAtom(bbLProj, 'P', alphaMolecular)});
            // Connector to Base
            queue.push({z: bbL.z, draw: () => drawLine(bbLProj, lProj[0], BOND_COLOR, 1, false, alphaMolecular)});

            // Right Backbone
            const bbR = rotateY({x: RADIUS, y: yBase, z: 0}, twistAngle);
            const bbRProj = project(bbR);
            queue.push({z: bbR.z, draw: () => drawAtom(bbRProj, 'P', alphaMolecular)});
            queue.push({z: bbR.z, draw: () => drawLine(bbRProj, rProj[0], BOND_COLOR, 1, false, alphaMolecular)});
            
            // Connect Backbones vertically
            if (i > 0) {
                const prevY = yBase - RISE;
                const prevTwist = (i - 1) * TWIST + globalTime;
                
                const prevBBL = project(rotateY({x: -RADIUS, y: prevY, z: 0}, prevTwist));
                queue.push({z: bbL.z, draw: () => drawLine(prevBBL, bbLProj, P_COLOR, 4, false, alphaMolecular)});

                const prevBBR = project(rotateY({x: RADIUS, y: prevY, z: 0}, prevTwist));
                queue.push({z: bbR.z, draw: () => drawLine(prevBBR, bbRProj, P_COLOR, 4, false, alphaMolecular)});
            }
        }

        // --- SCHEMATIC VIEW ---
        if (alphaSchematic > 0.05) {
            // Simplified endpoints
            const p1 = rotateY({x: -RADIUS*0.8, y: yBase, z: 0}, twistAngle);
            const p2 = rotateY({x: RADIUS*0.8, y: yBase, z: 0}, twistAngle);
            const proj1 = project(p1);
            const proj2 = project(p2);

            queue.push({z: p1.z, draw: () => {
                // Ladder rung
                drawLine(proj1, proj2, '#333', 3, false, alphaSchematic);
                
                // Labels
                ctx.globalAlpha = alphaSchematic;
                ctx.font = `bold ${24 * proj1.scale}px 'Patrick Hand'`;
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.fillText(leftType, proj1.x, proj1.y);
                ctx.fillText(rightType, proj2.x, proj2.y);
                
                // Bond type Label (2 vs 3 lines)
                const cx = (proj1.x + proj2.x)/2;
                const cy = (proj1.y + proj2.y)/2;
                const bonds = (leftType === 'A' || leftType === 'T') ? '||' : '|||';
                ctx.font = `${16 * proj1.scale}px sans-serif`;
                ctx.fillText(bonds, cx, cy);

                // Strand Labels (5' / 3')
                if (i === 0) {
                    ctx.font = `bold ${30 * proj1.scale}px 'Patrick Hand'`;
                    ctx.fillText("5'", proj1.x - 40*proj1.scale, proj1.y);
                    ctx.fillText("3'", proj2.x + 40*proj2.scale, proj2.y);
                } else if (i === BASE_PAIRS - 1) {
                    ctx.font = `bold ${30 * proj1.scale}px 'Patrick Hand'`;
                    ctx.fillText("3'", proj1.x - 40*proj1.scale, proj1.y);
                    ctx.fillText("5'", proj2.x + 40*proj2.scale, proj2.y);
                }
                ctx.globalAlpha = 1;
            }});
        }
    }

    // 4. Sort and Draw
    queue.sort((a, b) => b.z - a.z);
    queue.forEach(item => item.draw());

    requestAnimationFrame(animate);
}

// Start
animate();
</script>